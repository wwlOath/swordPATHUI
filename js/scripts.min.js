!function() {
  "use strict";
  angular.module("ui.tree", []).constant("treeConfig", {
    treeClass: "angular-ui-tree",
    emptyTreeClass: "angular-ui-tree-empty",
    dropzoneClass: "angular-ui-tree-dropzone",
    hiddenClass: "angular-ui-tree-hidden",
    nodesClass: "angular-ui-tree-nodes",
    nodeClass: "angular-ui-tree-node",
    handleClass: "angular-ui-tree-handle",
    placeholderClass: "angular-ui-tree-placeholder",
    dragClass: "angular-ui-tree-drag",
    dragThreshold: 3,
    defaultCollapsed: !1,
    appendChildOnHover: !0
  })
}(),
    function() {
      "use strict";
      angular.module("ui.tree").controller("TreeHandleController", ["$scope", "$element", function(e, n) {
        (this.scope = e).$element = n,
            e.$nodeScope = null,
            e.$type = "uiTreeHandle"
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").controller("TreeNodeController", ["$scope", "$element", function(t, o) {
        (this.scope = t).$element = o,
            t.$modelValue = null,
            t.$parentNodeScope = null,
            t.$childNodesScope = null,
            t.$parentNodesScope = null,
            t.$treeScope = null,
            t.$handleScope = null,
            t.$type = "uiTreeNode",
            t.$$allowNodeDrop = !1,
            t.collapsed = !1,
            t.expandOnHover = !1,
            t.init = function(e) {
              var n = e[0];
              t.$treeScope = e[1] ? e[1].scope : null,
                  t.$parentNodeScope = n.scope.$nodeScope,
                  t.$modelValue = n.scope.$modelValue[t.$index],
                  t.$parentNodesScope = n.scope,
                  n.scope.initSubNode(t),
                  o.on("$destroy", function() {
                    n.scope.destroySubNode(t)
                  })
            }
            ,
            t.index = function() {
              return t.$parentNodesScope.$modelValue.indexOf(t.$modelValue)
            }
            ,
            t.dragEnabled = function() {
              return !(t.$treeScope && !t.$treeScope.dragEnabled)
            }
            ,
            t.isSibling = function(e) {
              return t.$parentNodesScope == e.$parentNodesScope
            }
            ,
            t.isChild = function(e) {
              var n = t.childNodes();
              return n && -1 < n.indexOf(e)
            }
            ,
            t.prev = function() {
              var e = t.index();
              return 0 < e ? t.siblings()[e - 1] : null
            }
            ,
            t.siblings = function() {
              return t.$parentNodesScope.childNodes()
            }
            ,
            t.childNodesCount = function() {
              return t.childNodes() ? t.childNodes().length : 0
            }
            ,
            t.hasChild = function() {
              return 0 < t.childNodesCount()
            }
            ,
            t.childNodes = function() {
              return t.$childNodesScope && t.$childNodesScope.$modelValue ? t.$childNodesScope.childNodes() : null
            }
            ,
            t.accept = function(e, n) {
              return t.$childNodesScope && t.$childNodesScope.$modelValue && t.$childNodesScope.accept(e, n)
            }
            ,
            t.remove = function() {
              return t.$parentNodesScope.removeNode(t)
            }
            ,
            t.toggle = function() {
              t.collapsed = !t.collapsed,
                  t.$treeScope.$callbacks.toggle(t.collapsed, t)
            }
            ,
            t.collapse = function() {
              t.collapsed = !0
            }
            ,
            t.expand = function() {
              t.collapsed = !1
            }
            ,
            t.depth = function() {
              var e = t.$parentNodeScope;
              return e ? e.depth() + 1 : 1
            }
            ,
            t.maxSubDepth = function() {
              return t.$childNodesScope ? function e(n) {
                if (!n)
                  return 0;
                var t, o, r = 0, l = n.childNodes();
                if (!l || 0 === l.length)
                  return 0;
                for (o = l.length - 1; 0 <= o; o--)
                  t = 1 + e(l[o]),
                      r = Math.max(r, t);
                return r
              }(t.$childNodesScope) : 0
            }
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").controller("TreeNodesController", ["$scope", "$element", "$timeout", function(t, e, o) {
        (this.scope = t).$element = e,
            t.$modelValue = null,
            t.$nodeScope = null,
            t.$treeScope = null,
            t.$type = "uiTreeNodes",
            t.$nodesMap = {},
            t.nodropEnabled = !1,
            t.maxDepth = 0,
            t.cloneEnabled = !1,
            t.initSubNode = function(e) {
              if (!e.$modelValue)
                return null;
              t.$nodesMap[e.$modelValue.$$hashKey] = e
            }
            ,
            t.destroySubNode = function(e) {
              if (!e.$modelValue)
                return null;
              t.$nodesMap[e.$modelValue.$$hashKey] = null
            }
            ,
            t.accept = function(e, n) {
              return t.$treeScope.$callbacks.accept(e, t, n)
            }
            ,
            t.beforeDrag = function(e) {
              return t.$treeScope.$callbacks.beforeDrag(e)
            }
            ,
            t.isParent = function(e) {
              return e.$parentNodesScope == t
            }
            ,
            t.hasChild = function() {
              return 0 < t.$modelValue.length
            }
            ,
            t.removeNode = function(e) {
              var n = t.$modelValue.indexOf(e.$modelValue);
              return -1 < n ? (o(function() {
                t.$modelValue.splice(n, 1)[0]
              }),
                  t.$treeScope.$callbacks.removed(e)) : null
            }
            ,
            t.insertNode = function(e, n) {
              o(function() {
                t.$modelValue.splice(e, 0, n)
              })
            }
            ,
            t.childNodes = function() {
              var e, n = [];
              if (t.$modelValue)
                for (e = 0; e < t.$modelValue.length; e++)
                  n.push(t.$nodesMap[t.$modelValue[e].$$hashKey]);
              return n
            }
            ,
            t.depth = function() {
              return t.$nodeScope ? t.$nodeScope.depth() : 0
            }
            ,
            t.outOfDepth = function(e) {
              var n = t.maxDepth || t.$treeScope.maxDepth;
              return 0 < n && t.depth() + e.maxSubDepth() + 1 > n
            }
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").controller("TreeController", ["$scope", "$element", function(n, e) {
        (this.scope = n).$element = e,
            n.$nodesScope = null,
            n.$type = "uiTree",
            n.$emptyElm = null,
            n.$dropzoneElm = null,
            n.$callbacks = null,
            n.dragEnabled = !0,
            n.emptyPlaceholderEnabled = !0,
            n.maxDepth = 0,
            n.dragDelay = 0,
            n.cloneEnabled = !1,
            n.nodropEnabled = !1,
            n.dropzoneEnabled = !1,
            n.isEmpty = function() {
              return n.$nodesScope && n.$nodesScope.$modelValue && 0 === n.$nodesScope.$modelValue.length
            }
            ,
            n.place = function(e) {
              n.$nodesScope.$element.append(e),
                  n.$emptyElm.remove()
            }
            ,
            this.resetEmptyElement = function() {
              n.$nodesScope.$modelValue && 0 !== n.$nodesScope.$modelValue.length || !n.emptyPlaceholderEnabled ? n.$emptyElm.remove() : e.append(n.$emptyElm)
            }
            ,
            this.resetDropzoneElement = function() {
              n.$nodesScope.$modelValue && 0 === n.$nodesScope.$modelValue.length || !n.dropzoneEnabled ? n.$dropzoneElm.remove() : e.append(n.$dropzoneElm)
            }
            ,
            n.resetEmptyElement = this.resetEmptyElement,
            n.resetDropzoneElement = this.resetDropzoneElement
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").directive("uiTree", ["treeConfig", "$window", function(c, s) {
        return {
          restrict: "A",
          scope: !0,
          controller: "TreeController",
          link: function(t, e, n, o) {
            var r, l, a, i = {
              accept: null,
              beforeDrag: null
            }, d = {};
            angular.extend(d, c),
            d.treeClass && e.addClass(d.treeClass),
                "table" === e.prop("tagName").toLowerCase() ? (t.$emptyElm = angular.element(s.document.createElement("tr")),
                    a = 0 < (l = e.find("tr")).length ? angular.element(l).children().length : 1e6,
                    r = angular.element(s.document.createElement("td")).attr("colspan", a),
                    t.$emptyElm.append(r)) : (t.$emptyElm = angular.element(s.document.createElement("div")),
                    t.$dropzoneElm = angular.element(s.document.createElement("div"))),
            d.emptyTreeClass && t.$emptyElm.addClass(d.emptyTreeClass),
            d.dropzoneClass && t.$dropzoneElm.addClass(d.dropzoneClass),
                t.$watch("$nodesScope.$modelValue.length", function(e) {
                  angular.isNumber(e) && (o.resetEmptyElement(),
                      o.resetDropzoneElement())
                }, !0),
                t.$watch(n.dragEnabled, function(e) {
                  "boolean" == typeof e && (t.dragEnabled = e)
                }),
                t.$watch(n.emptyPlaceholderEnabled, function(e) {
                  "boolean" == typeof e && (t.emptyPlaceholderEnabled = e,
                      o.resetEmptyElement())
                }),
                t.$watch(n.nodropEnabled, function(e) {
                  "boolean" == typeof e && (t.nodropEnabled = e)
                }),
                t.$watch(n.dropzoneEnabled, function(e) {
                  "boolean" == typeof e && (t.dropzoneEnabled = e,
                      o.resetDropzoneElement())
                }),
                t.$watch(n.cloneEnabled, function(e) {
                  "boolean" == typeof e && (t.cloneEnabled = e)
                }),
                t.$watch(n.maxDepth, function(e) {
                  "number" == typeof e && (t.maxDepth = e)
                }),
                t.$watch(n.dragDelay, function(e) {
                  "number" == typeof e && (t.dragDelay = e)
                }),
                i.accept = function(e, n, t) {
                  return !(n.nodropEnabled || n.$treeScope.nodropEnabled || n.outOfDepth(e))
                }
                ,
                i.beforeDrag = function(e) {
                  return !0
                }
                ,
                i.expandTimeoutStart = function() {}
                ,
                i.expandTimeoutCancel = function() {}
                ,
                i.expandTimeoutEnd = function() {}
                ,
                i.removed = function(e) {}
                ,
                i.dropped = function(e) {}
                ,
                i.dragStart = function(e) {}
                ,
                i.dragMove = function(e) {}
                ,
                i.dragStop = function(e) {}
                ,
                i.beforeDrop = function(e) {}
                ,
                i.toggle = function(e, n) {}
                ,
                t.$watch(n.uiTree, function(e, n) {
                  angular.forEach(e, function(e, n) {
                    i[n] && "function" == typeof e && (i[n] = e)
                  }),
                      t.$callbacks = i
                }, !0)
          }
        }
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").directive("uiTreeHandle", ["treeConfig", function(l) {
        return {
          require: "^uiTreeNode",
          restrict: "A",
          scope: !0,
          controller: "TreeHandleController",
          link: function(e, n, t, o) {
            var r = {};
            angular.extend(r, l),
            r.handleClass && n.addClass(r.handleClass),
            e != o.scope && (e.$nodeScope = o.scope,
                o.scope.$handleScope = e)
          }
        }
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").directive("uiTreeNode", ["treeConfig", "UiTreeHelper", "$window", "$document", "$timeout", "$q", function(E, I, F, L, P, _) {
        return {
          require: ["^uiTreeNodes", "^uiTree"],
          restrict: "A",
          controller: "TreeNodeController",
          link: function(N, u, n, e) {
            var y, x, C, w, p, H, D, O, M, A, Y, t, o, r, l, a, i, d, c, s, m, f, h, X, g, $, V, b, z = {}, v = "ontouchstart"in window, k = null, S = document.body, T = document.documentElement;
            angular.extend(z, E),
            z.nodeClass && u.addClass(z.nodeClass),
                N.init(e),
                N.collapsed = !!I.getNodeAttribute(N, "collapsed") || E.defaultCollapsed,
                N.expandOnHover = !!I.getNodeAttribute(N, "expandOnHover"),
                N.scrollContainer = I.getNodeAttribute(N, "scrollContainer") || n.scrollContainer || null,
                N.sourceOnly = N.nodropEnabled || N.$treeScope.nodropEnabled,
                N.$watch(n.collapsed, function(e) {
                  "boolean" == typeof e && (N.collapsed = e)
                }),
                N.$watch("collapsed", function(e) {
                  I.setNodeAttribute(N, "collapsed", e),
                      n.$set("collapsed", e)
                }),
                N.$watch(n.expandOnHover, function(e) {
                  "boolean" != typeof e && "number" != typeof e || (N.expandOnHover = e)
                }),
                N.$watch("expandOnHover", function(e) {
                  I.setNodeAttribute(N, "expandOnHover", e),
                      n.$set("expandOnHover", e)
                }),
                n.$observe("scrollContainer", function(e) {
                  "string" == typeof e && (N.scrollContainer = e)
                }),
                N.$watch("scrollContainer", function(e) {
                  I.setNodeAttribute(N, "scrollContainer", e),
                      n.$set("scrollContainer", e),
                      D = document.querySelector(e)
                }),
                N.$on("angular-ui-tree:collapse-all", function() {
                  N.collapsed = !0
                }),
                N.$on("angular-ui-tree:expand-all", function() {
                  N.collapsed = !1
                }),
                t = function(e) {
                  if ((v || 2 !== e.button && 3 !== e.which) && !(e.uiTreeDragging || e.originalEvent && e.originalEvent.uiTreeDragging)) {
                    var n, t, o, r, l, a, i, d, c, s = angular.element(e.target);
                    if ((n = I.treeNodeHandlerContainerOfElement(s)) && (s = angular.element(n)),
                        t = u.clone(),
                        d = I.elementIsTreeNode(s),
                        c = I.elementIsTreeNodeHandle(s),
                    (d || c) && !(d && I.elementContainsTreeNodeHandler(s) || "input" == (o = s.prop("tagName").toLowerCase()) || "textarea" == o || "button" == o || "select" == o)) {
                      for (g = angular.element(e.target),
                               $ = g[0].attributes["ui-tree"]; g && g[0] && g[0] !== u && !$; ) {
                        if (g[0].attributes && ($ = g[0].attributes["ui-tree"]),
                            I.nodrag(g))
                          return;
                        g = g.parent()
                      }
                      N.beforeDrag(N) && (e.uiTreeDragging = !0,
                      e.originalEvent && (e.originalEvent.uiTreeDragging = !0),
                          e.preventDefault(),
                          l = I.eventObj(e),
                          y = !0,
                          x = I.dragInfo(N),
                          V = x.source.$treeScope.$id,
                          "tr" === (r = u.prop("tagName")).toLowerCase() ? (w = angular.element(F.document.createElement(r)),
                              a = angular.element(F.document.createElement("td")).addClass(z.placeholderClass).attr("colspan", u[0].children.length),
                              w.append(a)) : w = angular.element(F.document.createElement(r)).addClass(z.placeholderClass),
                          p = angular.element(F.document.createElement(r)),
                      z.hiddenClass && p.addClass(z.hiddenClass),
                          C = I.positionStarted(l, u),
                          w.css("height", u.prop("offsetHeight") + "px"),
                          (H = angular.element(F.document.createElement(N.$parentNodesScope.$element.prop("tagName"))).addClass(N.$parentNodesScope.$element.attr("class")).addClass(z.dragClass)).css("width", I.width(u) + "px"),
                          H.css("z-index", 9999),
                      (i = (u[0].querySelector(".angular-ui-tree-handle") || u[0]).currentStyle) && (document.body.setAttribute("ui-tree-cursor", L.find("body").css("cursor") || ""),
                          L.find("body").css({
                            cursor: i.cursor + "!important"
                          })),
                      N.sourceOnly && w.css("display", "none"),
                          u.after(w),
                          u.after(p),
                          x.isClone() && N.sourceOnly ? H.append(t) : H.append(u),
                          L.find("body").append(H),
                          H.css({
                            left: l.pageX - C.offsetX + "px",
                            top: l.pageY - C.offsetY + "px"
                          }),
                          M = {
                            placeholder: w,
                            dragging: H
                          },
                          m(),
                          N.$apply(function() {
                            N.$treeScope.$callbacks.dragStart(x.eventArgs(M, C))
                          }),
                          A = Math.max(S.scrollHeight, S.offsetHeight, T.clientHeight, T.scrollHeight, T.offsetHeight),
                          Y = Math.max(S.scrollWidth, S.offsetWidth, T.clientWidth, T.scrollWidth, T.offsetWidth))
                    }
                  }
                }
                ,
                o = function(e) {
                  var n, t, o, r, l, a, i, d, c, s, u, p, m, f, h, g, $, b, v, S, T, E = I.eventObj(e);
                  if (H) {
                    if (e.preventDefault(),
                        F.getSelection ? F.getSelection().removeAllRanges() : F.document.selection && F.document.selection.empty(),
                    (t = E.pageX - C.offsetX) < 0 && (t = 0),
                    (o = E.pageY - C.offsetY) < 0 && (o = 0),
                    A < o + 10 && (o = A - 10),
                    Y < t + 10 && (t = Y - 10),
                        H.css({
                          left: t + "px",
                          top: o + "px"
                        }),
                        D ? (a = D.getBoundingClientRect(),
                            l = (r = D.scrollTop) + D.clientHeight,
                        a.bottom < E.clientY && l < D.scrollHeight && (f = Math.min(D.scrollHeight - l, 10),
                            D.scrollTop += f),
                        a.top > E.clientY && 0 < r && (h = Math.min(r, 10),
                            D.scrollTop -= h)) : ((l = (r = window.pageYOffset || F.document.documentElement.scrollTop) + (window.innerHeight || F.document.clientHeight || F.document.clientHeight)) < E.pageY && l < A && (f = Math.min(A - l, 10),
                            window.scrollBy(0, f)),
                        r > E.pageY && (h = Math.min(r, 10),
                            window.scrollBy(0, -h))),
                        I.positionMoved(e, C, y),
                        y)
                      return void (y = !1);
                    if (d = E.pageX - (F.pageXOffset || F.document.body.scrollLeft || F.document.documentElement.scrollLeft) - (F.document.documentElement.clientLeft || 0),
                        c = E.pageY - (F.pageYOffset || F.document.body.scrollTop || F.document.documentElement.scrollTop) - (F.document.documentElement.clientTop || 0),
                        angular.isFunction(H.hide) ? H.hide() : (s = H[0].style.display,
                            H[0].style.display = "none"),
                        F.document.elementFromPoint(d, c),
                        p = angular.element(F.document.elementFromPoint(d, c)),
                    (X = I.treeNodeHandlerContainerOfElement(p)) && (p = angular.element(X)),
                        angular.isFunction(H.show) ? H.show() : H[0].style.display = s,
                        I.elementIsTree(p) ? u = p.controller("uiTree").scope : I.elementIsTreeNodeHandle(p) ? u = p.controller("uiTreeHandle").scope : I.elementIsTreeNode(p) ? u = p.controller("uiTreeNode").scope : I.elementIsTreeNodes(p) || I.elementIsPlaceholder(p) ? u = p.controller("uiTreeNodes").scope : I.elementIsDropzone(p) ? (u = p.controller("uiTree").scope,
                            T = !0) : p.controller("uiTreeNode") && (u = p.controller("uiTreeNode").scope),
                    u && u.$treeScope && u.$treeScope.$id && u.$treeScope.$id === V && C.dirAx)
                      0 < C.distX && (n = x.prev()) && !n.collapsed && n.accept(N, n.childNodesCount()) && (n.$childNodesScope.$element.append(w),
                          x.moveTo(n.$childNodesScope, n.childNodes(), n.childNodesCount())),
                      C.distX < 0 && (x.next() || (i = x.parentNode()) && i.$parentNodesScope.accept(N, i.index() + 1) && (i.$element.after(w),
                          x.moveTo(i.$parentNodesScope, i.siblings(), i.index() + 1)));
                    else {
                      if (m = !1,
                          !u)
                        return;
                      if (!u.$treeScope || u.$parent.nodropEnabled || u.$treeScope.nodropEnabled || w.css("display", ""),
                      "uiTree" === u.$type && u.dragEnabled && (m = u.isEmpty()),
                      "uiTreeHandle" === u.$type && (u = u.$nodeScope),
                      "uiTreeNode" !== u.$type && !m && !T)
                        return void (z.appendChildOnHover && !x.next() && O && ((i = x.parentNode()).$element.after(w),
                            x.moveTo(i.$parentNodesScope, i.siblings(), i.index() + 1),
                            O = !1));
                      k && w.parent()[0] != k.$element[0] && (k.resetEmptyElement(),
                          k.resetDropzoneElement(),
                          k = null),
                          m ? (k = u).$nodesScope.accept(N, 0) && x.moveTo(u.$nodesScope, u.$nodesScope.childNodes(), 0) : T ? (k = u).$nodesScope.accept(N, u.$nodesScope.childNodes().length) && x.moveTo(u.$nodesScope, u.$nodesScope.childNodes(), u.$nodesScope.childNodes().length) : u.dragEnabled() && (angular.isDefined(N.expandTimeoutOn) && N.expandTimeoutOn !== u.id && (P.cancel(N.expandTimeout),
                              delete N.expandTimeout,
                              delete N.expandTimeoutOn,
                              N.$callbacks.expandTimeoutCancel()),
                          u.collapsed && (!0 === N.expandOnHover || angular.isNumber(N.expandOnHover) && 0 === N.expandOnHover ? (u.collapsed = !1,
                              u.$treeScope.$callbacks.toggle(!1, u)) : !1 !== N.expandOnHover && angular.isNumber(N.expandOnHover) && 0 < N.expandOnHover && angular.isUndefined(N.expandTimeoutOn) && (N.expandTimeoutOn = u.$id,
                              N.$callbacks.expandTimeoutStart(),
                              N.expandTimeout = P(function() {
                                N.$callbacks.expandTimeoutEnd(),
                                    u.collapsed = !1,
                                    u.$treeScope.$callbacks.toggle(!1, u)
                              }, N.expandOnHover))),
                              p = u.$element,
                              g = I.offset(p),
                              v = I.height(p),
                              v -= (S = u.$childNodesScope ? u.$childNodesScope.$element : null) ? I.height(S) : 0,
                              b = z.appendChildOnHover ? .25 * v : I.height(p) / 2,
                              $ = E.pageY < g.top + b,
                              u.$parentNodesScope.accept(N, u.index()) ? $ ? (p[0].parentNode.insertBefore(w[0], p[0]),
                                  x.moveTo(u.$parentNodesScope, u.siblings(), u.index())) : z.appendChildOnHover && u.accept(N, u.childNodesCount()) ? (u.$childNodesScope.$element.prepend(w),
                                  x.moveTo(u.$childNodesScope, u.childNodes(), 0),
                                  O = !0) : (p.after(w),
                                  x.moveTo(u.$parentNodesScope, u.siblings(), u.index() + 1)) : !$ && u.accept(N, u.childNodesCount()) && (u.$childNodesScope.$element.append(w),
                                  x.moveTo(u.$childNodesScope, u.childNodes(), u.childNodesCount())))
                    }
                    N.$apply(function() {
                      N.$treeScope.$callbacks.dragMove(x.eventArgs(M, C))
                    })
                  }
                }
                ,
                r = function(e) {
                  var n = x.eventArgs(M, C);
                  e.preventDefault(),
                      f(),
                      P.cancel(N.expandTimeout),
                      N.$treeScope.$apply(function() {
                        _.when(N.$treeScope.$callbacks.beforeDrop(n)).then(function(e) {
                          !1 !== e && N.$$allowNodeDrop ? (x.apply(),
                              N.$treeScope.$callbacks.dropped(n)) : s()
                        }).catch(function() {
                          s()
                        }).finally(function() {
                          p.replaceWith(N.$element),
                              w.remove(),
                          H && (H.remove(),
                              H = null),
                              N.$treeScope.$callbacks.dragStop(n),
                              N.$$allowNodeDrop = !1,
                              x = null;
                          var e = document.body.getAttribute("ui-tree-cursor");
                          null !== e && (L.find("body").css({
                            cursor: e
                          }),
                              document.body.removeAttribute("ui-tree-cursor"))
                        })
                      })
                }
                ,
                l = function(e) {
                  N.dragEnabled() && t(e)
                }
                ,
                a = function(e) {
                  o(e)
                }
                ,
                i = function(e) {
                  N.$$allowNodeDrop = !0,
                      r(e)
                }
                ,
                d = function(e) {
                  r(e)
                }
                ,
                c = {
                  exec: function(e, n) {
                    n = n || 0,
                        this.cancel(),
                        b = P(e, n)
                  },
                  cancel: function() {
                    P.cancel(b)
                  }
                },
                h = function(e) {
                  27 === e.keyCode && i(e)
                }
                ,
                (s = function() {
                      u.bind("touchstart mousedown", function(e) {
                        0 < N.dragDelay ? c.exec(function() {
                          l(e)
                        }, N.dragDelay) : l(e)
                      }),
                          u.bind("touchend touchcancel mouseup", function() {
                            0 < N.dragDelay && c.cancel()
                          })
                    }
                )(),
                m = function() {
                  angular.element(L).bind("touchend", i),
                      angular.element(L).bind("touchcancel", i),
                      angular.element(L).bind("touchmove", a),
                      angular.element(L).bind("mouseup", i),
                      angular.element(L).bind("mousemove", a),
                      angular.element(L).bind("mouseleave", d),
                      angular.element(L).bind("keydown", h)
                }
                ,
                f = function() {
                  angular.element(L).unbind("touchend", i),
                      angular.element(L).unbind("touchcancel", i),
                      angular.element(L).unbind("touchmove", a),
                      angular.element(L).unbind("mouseup", i),
                      angular.element(L).unbind("mousemove", a),
                      angular.element(L).unbind("mouseleave", d),
                      angular.element(L).unbind("keydown", h)
                }
          }
        }
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").directive("uiTreeNodes", ["treeConfig", "$window", function(d) {
        return {
          require: ["ngModel", "?^uiTreeNode", "^uiTree"],
          restrict: "A",
          scope: !0,
          controller: "TreeNodesController",
          link: function(n, e, t, o) {
            var r = {}
                , l = o[0]
                , a = o[1]
                , i = o[2];
            angular.extend(r, d),
            r.nodesClass && e.addClass(r.nodesClass),
                a ? (a.scope.$childNodesScope = n).$nodeScope = a.scope : i.scope.$nodesScope = n,
                n.$treeScope = i.scope,
            l && (l.$render = function() {
                  n.$modelValue = l.$modelValue
                }
            ),
                n.$watch(function() {
                  return t.maxDepth
                }, function(e) {
                  "number" == typeof e && (n.maxDepth = e)
                }),
                n.$watch(function() {
                  return t.nodropEnabled
                }, function(e) {
                  void 0 !== e && (n.nodropEnabled = !0)
                }, !0)
          }
        }
      }
      ])
    }(),
    function() {
      "use strict";
      angular.module("ui.tree").factory("UiTreeHelper", ["$document", "$window", "treeConfig", function(t, o, n) {
        return {
          nodesData: {},
          setNodeAttribute: function(e, n, t) {
            if (!e.$modelValue)
              return null;
            var o = this.nodesData[e.$modelValue.$$hashKey];
            o || (o = {},
                this.nodesData[e.$modelValue.$$hashKey] = o),
                o[n] = t
          },
          getNodeAttribute: function(e, n) {
            if (!e.$modelValue)
              return null;
            var t = this.nodesData[e.$modelValue.$$hashKey];
            return t ? t[n] : null
          },
          nodrag: function(e) {
            return void 0 !== e.attr("data-nodrag") && "false" !== e.attr("data-nodrag")
          },
          eventObj: function(e) {
            var n = e;
            return void 0 !== e.targetTouches ? n = e.targetTouches.item(0) : void 0 !== e.originalEvent && void 0 !== e.originalEvent.targetTouches && (n = e.originalEvent.targetTouches.item(0)),
                n
          },
          dragInfo: function(e) {
            return {
              source: e,
              sourceInfo: {
                cloneModel: !0 === e.$treeScope.cloneEnabled ? angular.copy(e.$modelValue) : void 0,
                nodeScope: e,
                index: e.index(),
                nodesScope: e.$parentNodesScope
              },
              index: e.index(),
              siblings: e.siblings().slice(0),
              parent: e.$parentNodesScope,
              resetParent: function() {
                this.parent = e.$parentNodesScope
              },
              moveTo: function(e, n, t) {
                this.parent = e,
                    this.siblings = n.slice(0);
                var o = this.siblings.indexOf(this.source);
                -1 < o && (this.siblings.splice(o, 1),
                this.source.index() < t && t--),
                    this.siblings.splice(t, 0, this.source),
                    this.index = t
              },
              parentNode: function() {
                return this.parent.$nodeScope
              },
              prev: function() {
                return 0 < this.index ? this.siblings[this.index - 1] : null
              },
              next: function() {
                return this.index < this.siblings.length - 1 ? this.siblings[this.index + 1] : null
              },
              isClone: function() {
                return !0 === this.source.$treeScope.cloneEnabled
              },
              clonedNode: function(e) {
                return angular.copy(e)
              },
              isDirty: function() {
                return this.source.$parentNodesScope != this.parent || this.source.index() != this.index
              },
              isForeign: function() {
                return this.source.$treeScope !== this.parent.$treeScope
              },
              eventArgs: function(e, n) {
                return {
                  source: this.sourceInfo,
                  dest: {
                    index: this.index,
                    nodesScope: this.parent
                  },
                  elements: e,
                  pos: n
                }
              },
              apply: function() {
                var e = this.source.$modelValue;
                this.parent.nodropEnabled || this.parent.$treeScope.nodropEnabled || this.isDirty() && (this.isClone() && this.isForeign() ? this.parent.insertNode(this.index, this.sourceInfo.cloneModel) : (this.source.remove(),
                    this.parent.insertNode(this.index, e)))
              }
            }
          },
          height: function(e) {
            return e.prop("scrollHeight")
          },
          width: function(e) {
            return e.prop("scrollWidth")
          },
          offset: function(e) {
            var n = e[0].getBoundingClientRect();
            return {
              width: e.prop("offsetWidth"),
              height: e.prop("offsetHeight"),
              top: n.top + (o.pageYOffset || t[0].body.scrollTop || t[0].documentElement.scrollTop),
              left: n.left + (o.pageXOffset || t[0].body.scrollLeft || t[0].documentElement.scrollLeft)
            }
          },
          positionStarted: function(e, n) {
            var t = {}
                , o = e.pageX
                , r = e.pageY;
            return e.originalEvent && e.originalEvent.touches && 0 < e.originalEvent.touches.length && (o = e.originalEvent.touches[0].pageX,
                r = e.originalEvent.touches[0].pageY),
                t.offsetX = o - this.offset(n).left,
                t.offsetY = r - this.offset(n).top,
                t.startX = t.lastX = o,
                t.startY = t.lastY = r,
                t.nowX = t.nowY = t.distX = t.distY = t.dirAx = 0,
                t.dirX = t.dirY = t.lastDirX = t.lastDirY = t.distAxX = t.distAxY = 0,
                t
          },
          positionMoved: function(e, n, t) {
            var o, r = e.pageX, l = e.pageY;
            if (e.originalEvent && e.originalEvent.touches && 0 < e.originalEvent.touches.length && (r = e.originalEvent.touches[0].pageX,
                l = e.originalEvent.touches[0].pageY),
                n.lastX = n.nowX,
                n.lastY = n.nowY,
                n.nowX = r,
                n.nowY = l,
                n.distX = n.nowX - n.lastX,
                n.distY = n.nowY - n.lastY,
                n.lastDirX = n.dirX,
                n.lastDirY = n.dirY,
                n.dirX = 0 === n.distX ? 0 : 0 < n.distX ? 1 : -1,
                n.dirY = 0 === n.distY ? 0 : 0 < n.distY ? 1 : -1,
                o = Math.abs(n.distX) > Math.abs(n.distY) ? 1 : 0,
                t)
              return n.dirAx = o,
                  void (n.moving = !0);
            n.dirAx !== o ? (n.distAxX = 0,
                n.distAxY = 0) : (n.distAxX += Math.abs(n.distX),
            0 !== n.dirX && n.dirX !== n.lastDirX && (n.distAxX = 0),
                n.distAxY += Math.abs(n.distY),
            0 !== n.dirY && n.dirY !== n.lastDirY && (n.distAxY = 0)),
                n.dirAx = o
          },
          elementIsTreeNode: function(e) {
            return void 0 !== e.attr("ui-tree-node")
          },
          elementIsTreeNodeHandle: function(e) {
            return void 0 !== e.attr("ui-tree-handle")
          },
          elementIsTree: function(e) {
            return void 0 !== e.attr("ui-tree")
          },
          elementIsTreeNodes: function(e) {
            return void 0 !== e.attr("ui-tree-nodes")
          },
          elementIsPlaceholder: function(e) {
            return e.hasClass(n.placeholderClass)
          },
          elementIsDropzone: function(e) {
            return e.hasClass(n.dropzoneClass)
          },
          elementContainsTreeNodeHandler: function(e) {
            return 1 <= e[0].querySelectorAll("[ui-tree-handle]").length
          },
          treeNodeHandlerContainerOfElement: function(e) {
            return function(e, n) {
              if (void 0 === n)
                return null;
              var t = n.parentNode
                  , o = "function" == typeof t.setAttribute && t.hasAttribute(e) ? t : null;
              for (; t && "function" == typeof t.setAttribute && !t.hasAttribute(e); ) {
                if (t = t.parentNode,
                (o = t) === document.documentElement) {
                  o = null;
                  break
                }
                0
              }
              return o
            }("ui-tree-handle", e[0])
          }
        }
      }
      ])
    }();
var THEMEMASCOT = {};
!function(l) {
  "use strict";
  var e = l(document)
      , a = l("body");
  THEMEMASCOT.header = {
    init: function() {
      setTimeout(function() {
        THEMEMASCOT.header.TM_scrollToFixed(),
            THEMEMASCOT.header.TM_menuzord(),
            THEMEMASCOT.header.TM_scrolltoTarget()
      }, 0)
    },
    TM_scrollToFixed: function() {
      var e = l(".navbar-scrolltofixed");
      0 < e.length && e.scrollToFixed(),
      0 < (e = l(".scrolltofixed")).length && e.scrollToFixed({
        marginTop: l(".header-nav").outerHeight(!0) + 10,
        limit: function() {
          return l("#footer").offset().top - l(this).outerHeight(!0)
        }
      }),
      0 < (e = l("#sidebar")).length && e.scrollToFixed({
        marginTop: l(".header .header-nav").outerHeight() + 20,
        limit: function() {
          return l("#footer").offset().top - l("#sidebar").outerHeight() - 20
        }
      })
    },
    TM_menuzord: function() {
      var e = l("#menuzord");
      0 < e.length && e.menuzord({
        align: "left",
        effect: "slide",
        hideDelay: 200,
        animation: "none",
        indicatorFirstLevel: "<i class='fa fa-angle-down'></i>",
        indicatorSecondLevel: "<i class='fa fa-angle-right'></i>"
      })
    },
    TM_scrolltoTarget: function() {
      l(".smooth-scroll-to-target, .fullscreen-onepage-nav a").on("click", function(e) {
        e.preventDefault();
        var n = l(this)
            , t = l(" .header-nav")
            , o = 0;
        o = t[0] ? t.outerHeight(!0) : 0,
        a.hasClass("vertical-nav") && (o = 0);
        var r = l(n.attr("href")).offset().top - o;
        l("html, body").stop().animate({
          scrollTop: r
        }, 1500, "easeInOutExpo")
      })
    }
  },
      THEMEMASCOT.widget = {
        init: function() {
          setTimeout(function() {
            THEMEMASCOT.widget.TM_accordion_toggles()
          }, 0)
        },
        TM_accordion_toggles: function() {
          var t;
          l(document).on("show.bs.collapse hide.bs.collapse", function(e) {
            var n = l(e.target);
            "show" == e.type ? n.closest(".panel-group").find("[href='#" + n.attr("id") + "']").addClass("active") : "hide" == e.type && n.closest(".panel-group").find("[href='#" + n.attr("id") + "']").removeClass("active"),
                clearTimeout(t),
                t = setTimeout(function() {
                  l(window).trigger("scrollstop")
                }, 400)
          }).on("shown.bs.modal", function(e) {
            var n = l(e.target);
            n.find("input:first").select(),
            (n = n.find("iframe")).attr("src") || n.attr("src", n.attr("data-src"))
          })
        }
      },
      THEMEMASCOT.documentOnReady = {
        init: function() {
          THEMEMASCOT.header.init(),
              THEMEMASCOT.widget.init()
        }
      },
      e.ready(THEMEMASCOT.documentOnReady.init)
}(jQuery);
